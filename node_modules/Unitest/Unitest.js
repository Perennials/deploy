"use strict";

(function ( exports, global ) {

	var CMP_DEEP = 1;
	var CMP_STRICT = 2;
	var CMP_LOOSE = 4;
	var CMP_EXTENDS = 8;

	var _setup_UNITESTS_AUTORUN = false;
	var _setup_UNITESTS_NOCOLOR = false;
	var _setup_UNITESTS_READY = null;
	var _setup_UNITESTS_SILENTUNCAUGHT = false;
	var _setup_UNITESTS_ONLY_MODULE = true;
	var _setup_UNITESTS_ONLY_TEST = true;
	var _setup_UNITESTS = false;

	var _loaded = false;
	var _tests = null;
	var _started = 0;
	var _finished = 0;
	var _hadErrors = false;
	var _failed = 0;
	var _passed = 0;
	var _isNode = global.addEventListener === undefined;
	if ( _isNode ) {
		_setup_UNITESTS_AUTORUN = true;
	}
	var clr = {
		reset: '\x1B[0m',
		red: '\x1B[31m',
		green: '\x1B[32m',
		yellow: '\x1B[33m',
	};
	var _hadException = false;
	var _printed = false;
	var _currentModule = undefined;
	var _lastRunTest = 0;
	var _lastTest = 0;

	var _global_current = null;

	function _isInClr () {
		return _isNode && !_setup_UNITESTS_NOCOLOR;
	}

	function printStats () {

		if ( _printed ) {
			return;
		}
		_printed = true;
		var inclr = _isInClr();

		// if ( _hadException ) {
		// 	console.error(
		// 		( inclr ? clr.yellow : '' ) +
		// 		'Unitest failed: ' +
		// 		( inclr ? clr.reset : '' ) +
		// 		( 'Uncaught exception.' ) +
		// 		( inclr ? clr.reset : '' )
		// 	);
		// }

		if ( _started > _finished ) {
			for ( var i = 0, iend = _tests.length; i < iend; ++i ) {
				if ( !_tests[ i ].started || _tests[ i ].finished ) {
					continue;
				}
				
				console.error(
					( inclr ? clr.yellow : '' ) +
					'Unitest unfinished: ' +
					( inclr ? clr.reset : '' ) +
					_tests[ i ].name
				);
			}
		}

		console[ _hadErrors || _hadException || _failed > 0 || _started !== _finished ? 'error' : 'log' ](
			( inclr ? clr.yellow : '' ) +
			'Unitests: ' +
			( inclr ? clr.reset : '' ) +
			( 'started: ' + _started + ', ' ) +
			( inclr ? clr.reset : '' ) +
			( 'finished: ' ) +
			( inclr ? ( _started !== _finished ? clr.red : clr.green ) : '' ) +
			( _finished + ', ' ) +
			( inclr ? clr.reset : '' ) +
			( 'failed: ' ) +
			( inclr ? ( (_hadErrors || _hadException) ? clr.red : clr.green ) : '' ) +
			( (_hadErrors || _hadException) ? ( _failed > 0 ? _failed : '???' ) : 0 ) +
			( inclr ? clr.reset : '' )
		);
	}
	
	
	function _getStackTrace () {
		var stack = null;
		try {
			var e = new Error();

			// ie only have .stack in the catch block
			if ( e.stack ) {
				// not ie flow
				stack = e.stack.substr( e.toString().length + 1 );
			}
			else {
				// ie flow
				throw e;
			}
		}
		catch ( e ) {
			// ie flow
			stack = e.stack ? e.stack.substr( e.toString().length + 1 ) : null;
		}
		return stack || null;
	}

	function _getLineFromStack ( stack, offset ) {
		var lines = stack.split( '\n' ).slice( offset );

		var str = '(' + __filename + ':';
		for ( var i = 0, iend = lines.length; i < iend; ++i ) {
			if ( lines[ i ].indexOf( str ) > 0 ) {
				lines = lines.slice( 0, i );
				break;
			}
		}

		var inclr = _isInClr();
		lines = lines.map( function ( line ) {
       		line = line.trim();
   			if ( !line.match( /(?:\(| )[_a-zA-Z0-9]+\.js:\d+:\d+(?:\)|$)/ ) ) {
				if ( inclr ) {
					line = clr.green + line + clr.reset;
				}
				else if ( lines.length > 1 ) {
					line = '--> ' + line;
				}
			}
			else if ( !inclr && lines.length > 1 ) {
				line = '    ' + line;
			}
			return line;
		} );

		return lines.length == 1 ? lines[ 0 ] : "\n    " + lines.join( "\n    " );
	}

	function _testFailed ( text, stack, offset, _current ) {

		_hadErrors = true;

		var inclr = _isInClr();
		var line = stack ? ' called @' + _getLineFromStack( stack, offset ) : '';
		console.error(
			( inclr ? clr.yellow : '' ) +
			'Unitest failed: ' +
			( inclr ? clr.reset : '' ) +
			( text ? text + ' in test ' : '' ) +
			( inclr ? clr.green : '' ) +
			( _current.name ) +
			( inclr ? clr.reset : '' ) +
			line +
			( inclr ? clr.reset : '' )
		);

		if ( _current.failed === false ) {
			_current.failed = true;
			++_failed;
		}
	}

	/**
	Tests if a condition is met and throws an Error if it is not.
	
	@def static function test ( condition, text )
	
	@param any Will be tested with !condition
	@param string|undefined Description of the test.
	@throws Error
	@author Borislav Peev <borislav.asdf@gmail.com>
	*/
	function test ( condition, text, _current, _offset ) {
		if ( !condition ) {
			_testFailed( text, _getStackTrace(), 2 + ( _offset > 0 ? _offset : 0 ), _current );
		}
	}

	test.eq = testeq;
	test.eq._cmpDeep = _cmpDeep;
	test.out = testout;

	var _testRunning = false;

	function testin () {
		++_started;
	}

	/**
	Marks an async test as finished.

	Should be called for each async test.

	@def static function testout ()
	@author Borislav Peev <borislav.asdf@gmail.com>
	*/
	function testout ( _current ) {
		if ( _current.failed === false ) {
			++_passed;
		}
		_current.finished = true;
		++_finished;
		_testRunning = false;
		if ( _global_current === _current ) {
			_global_current = null;
		}

		if ( _tests instanceof Array &&
			 _tests.length === _started &&
			 _started === _finished ) {

			if ( _setup_UNITESTS_READY instanceof Function ) {
				_setup_UNITESTS_READY();
			}

			printStats();
		}
		else {
			_runTests();
		}
	}

	function _testeqText ( left, right, text ) {
		if ( !text ) {
			if ( !( typeof left == 'string' || left instanceof String ) || !( typeof right == 'string' || right instanceof String ) ) {
				left = JSON.stringify( left );
				right = JSON.stringify( right );
			}
			text = '\n---\n' + left + '\n--- equals ---\n' + right + '\n---\n';
		}
		return text;
	}

	/**
	Tests if two arguments are equal (recursively) and throws an Error if not.

	@def static function testeq ( left:mixed, right:mixed, text:string|undefined )
	@throws Error
	@author Borislav Peev <borislav.asdf@gmail.com>
	*/

	/**
	Tests if two arguments are equal and throws an Error if not.

	The value of `flags` can be one or more of the following:
	- `CMP_DEEP` - the arguments are compared deeply (recursively).
	- `CMP_LOOSE`, default - `==` is used for comparison. Since this is the
      default behaviour this flag is provided only for consistency and can be
      omitted.
	- `CMP_STRICT` - `===` is used for comparison.
	- `CMP_EXTENDS` - this applies to objects (not arrays) and means that only
      the properties from the first argument are are compared and even if the
      second argument has extra properties the test will pass. But if the left
      argument has a property that is undefined in the second argument, the
      test will fail. This value implies `CMP_DEEP`.
	- `true`, default - replaced with `CMP_DEEP`. Since this is the default
      behaviour this value is provided only for consistency and can be
      omitted.
	- `false` - means shallow and loose comparison.

	@def static function testeq ( left:mixed, right:mixed, flags:int|bool = true, text:string|undefined )
	@throws Error
	@author Borislav Peev <borislav.asdf@gmail.com>
	*/
	function testeq ( left, right, flags, text, _current, _offset ) {

		var cmp = null;

		if ( typeof flags == 'string' || flags instanceof String ) {
			text = flags;
			flags = CMP_DEEP;
		}

		if ( flags === undefined ) {
			flags = CMP_DEEP;
		}

		if ( typeof flags == 'number' || flags instanceof Number ) {
			if ( ( flags&CMP_EXTENDS ) && !(flags&CMP_DEEP) ) {
				flags |= CMP_DEEP;
			}
		}

		if ( flags === true ) {
			flags = CMP_DEEP;
		}
		else if ( flags === false ) {
			flags = CMP_LOOSE;
		}

		if ( flags&CMP_DEEP ) {
			cmp = _cmpDeep;
		}
		else {
			cmp = _cmpOne;
		}

		if ( !cmp( left, right, flags ) ) {
			text = _testeqText( left, right, text );
			_testFailed( text, _getStackTrace(), 2 + ( _offset > 0 ? _offset : 0 ), _current );
		}
	}


	function _cmpArray ( left, right, cmpfunc, flags ) {
		if ( left.length != right.length ) {
			return false;
		}
		for ( var i = left.length - 1; i >= 0; --i ) {
			if ( !cmpfunc( left[i], right[i], flags ) ) {
				return false;
			}
		}
		return true;
	}

	function _cmpObject ( left, right, cmpfunc, flags ) {
		
		if ( !(flags&CMP_EXTENDS) ) {
			
			var keysleft = Object.keys( left );
			var keysright = Object.keys( right );

			if ( keysleft.length != keysright.length ) {
				return false;
			}
			keysleft = keysleft.sort();
			keysright = keysright.sort();
			for ( var i = keysleft.length - 1; i >= 0; --i ) {
				if ( keysleft[i] !== keysright[i] ) {
					return false;
				}
			}

		}

		for ( var key in left ) {
			if ( !cmpfunc( left[key], right[key], flags ) ) {
				return false;
			}
		}

		return true;
	}

	function _cmpOne ( left, right, flags ) {
		if ( flags&CMP_STRICT ) {
			return left === right;
		}
		return left == right;
	}

	function _cmpDeep ( left, right, flags ) {
		if ( left instanceof Array && right instanceof Array ) {
			return _cmpArray( left, right, _cmpDeep, flags );
		}
		else if (
			left instanceof Object && Object.getPrototypeOf( left ) === Object.prototype &&
			right instanceof Object && Object.getPrototypeOf( right ) === Object.prototype
		) {
			return _cmpObject( left, right, _cmpDeep, flags )
		}
		else {
			return _cmpOne( left, right, flags );
		}
	}

	//private
	function runTest ( testN ) {

		var ptest = _tests[ testN ];
		var name = ptest[ 0 ];
		var testcb = ptest[ 1 ];
		var _async = ptest[ 2 ];

		if ( name instanceof Function ) {
			testcb = name;
			name = '[unnamed test ' + (++_lastTest) + ']';
		}
		
		var current = { name: name, test: test, failed: false, finished: false, index: testN, started: true };
		_tests[ testN ] = current;

		function _test ( condition, text ) {
			return test( condition, text, current, 1 );
		}

		_test.eq = function ( left, right, deep, text ) {
			return testeq( left, right, deep, text, current, 1 );
		}

		_test.eq._cmpDeep = _cmpDeep;

		_test.out = function () {
			if ( !_async ) {
				var inclr = _isInClr();

				console.error(
					( inclr ? clr.yellow : '' ) +
					'Unitest warning: ' +
					( inclr ? clr.reset : '' ) +
					( 'test.out() should be called only from UnitestA() ' ) +
					_getStackTrace().split( '\n' )[ 2 ].trim()
				);
				return;
			}
			return testout( current );
		}

		var caught = false;
		try {
			testin();
			_global_current = current;
			testcb( _test );
		}
		catch ( e ) {
			var text = e.toString();
			_testFailed( text, e.stack ? e.stack.substr( text.length + 1 ) : null, 0, current );
			testout( current );
			caught = true;
		}
		finally {
			if ( !_async && !caught ) {
				testout( current );
			}
		}
	}

	/**
	Creates an async test case. Test cases are executed when the document is loaded.

	@def static function UnitestA ( test )
	@param function Function performing the the test case.
	@author Borislav Peev <borislav.asdf@gmail.com>
	*/

	/**
	Creates an asyc test case. Test cases are executed when the document is loaded.

	@def static function UnitestA ( name, test )
	@param string Name of the test case.
	@param function Function performing the the test case.
	@author Borislav Peev <borislav.asdf@gmail.com>
	*/
	function UnitestA ( name, test ) {
		return Unitest( name, test, true );
	}

	/**
	Creates a test case. Test cases are executed when the document is loaded.

	@def static function Unitest ( test )
	@param function Function performing the the test case.
	@author Borislav Peev <borislav.asdf@gmail.com>
	*/

	/**
	Creates a test case. Test cases are executed when the document is loaded.

	@def static function Unitest ( name, test )
	@param string Name of the test case.
	@param function Function performing the the test case.
	@author Borislav Peev <borislav.asdf@gmail.com>
	*/

	function _runTests () {
		if ( _testRunning || _lastRunTest >= _tests.length ) {
			return false;
		}
		_testRunning = true;
		var test = _lastRunTest++;
		if ( _isNode ) {
			process.nextTick( function () { runTest( test ); } );
		}
		else {
			setTimeout( function () { runTest( test ); }, 1 );
		}
	}


	function Unitest ( name, test, _async ) {

		if ( _setup_UNITESTS === false ||
		     ( _isNode && _setup_UNITESTS === undefined ) ||
		     
		     ( _setup_UNITESTS_ONLY_MODULE !== true &&
		       _setup_UNITESTS_ONLY_MODULE !== _currentModule ) ||

		    ( _setup_UNITESTS_ONLY_TEST !== true &&
		       _setup_UNITESTS_ONLY_TEST !== name ) ) {
			return false;
		}

		if ( _tests === null ) {
			
			_tests = [];
			if ( !_setup_UNITESTS_AUTORUN  ) {
				
				var onload = function () {
					_loaded = true;

					_runTests();
				}
				
				
				global.addEventListener( 'load', onload );
			}
		}
		
		_tests.push( [ name, test, _async ] );
		
		if ( _loaded || _setup_UNITESTS_AUTORUN ) {
			
			_runTests();
		
		}
		
	}

	/**
	Disables error output on uncaught exception.

	@def static function Unitest.silentUncaught ()
	*/
	Unitest.silentUncaught = function () {
		_setup_UNITESTS_SILENTUNCAUGHT = true;
		return Unitest;
	};

	/**
	Sets a callback to be notified after all unitests complete.

	@def static function Unitest.onReady ( callback )
	@param function
	*/
	Unitest.onReady = function ( callback ) {
		_setup_UNITESTS_READY = callback;
		return Unitest;
	};

	/**
	Disables colorful console output in node.js.

	@def static function Unitest.noColor ()
	*/
	Unitest.noColor = function () {
		_setup_UNITESTS_NOCOLOR = true;
		return Unitest;
	};


	/**
	Run tests immediately instead of on `document.load`.

	@def static function Unitest.autorun ()
	*/
	Unitest.autorun = function () {
		_setup_UNITESTS_AUTORUN = true;
		return Unitest;
	};

	/**
	Enables the unitests.

	@def static function Unitest.enable ()
	*/
	Unitest.enable = function () {
		_setup_UNITESTS = true;
		
		if ( _isNode ) {

			process.on( 'uncaughtException', function ( e ) {
				_hadException = true;
				var nootherlisteners = (process.listeners( 'uncaughtException' ).length === 1);

				if ( nootherlisteners || _setup_UNITESTS_SILENTUNCAUGHT !== true ) {

					if ( _global_current ) {
						var text = e.toString();
						_testFailed( text, e.stack ? e.stack.substr( text.length + 1 ) : null, 0, _global_current );
						testout( _global_current );
					}
					else {
						console.error( e.stack.toString() );
					}
				}
				if ( nootherlisteners ) {
					process.exit( 1 );
				}
			} );

			var exitListener = function ( code ) {

				var listeners = process.listeners( 'exit' );
				if ( listeners.length > 0 ) {
					for ( var i = 0, iend = listeners.length; i < iend; ++i ) {
						var listener = listeners[ i ];
						if ( listener !== exitListener ) {
							listener( code );
						}
					}
				}
				
				if ( _hadErrors || _hadException ) {
					code = code > 0 ? code : 1;
				}
				else if ( _passed > 0 ) {
					code = code > 0 ? code : 0;
				}

				printStats();
				process.exit( code );
			};

			process.on( 'exit', exitListener );
		}
		else {
			global.addEventListener( 'error', function () {
				_hadException = true;
			} );
		}

		// if ( !_isNode || _setup_UNITESTS === true ) {
			exports.log = function () { return console.log.apply( console, arguments ); };
			exports.CMP_DEEP = CMP_DEEP;
			exports.CMP_STRICT = CMP_STRICT;
			exports.CMP_LOOSE = CMP_LOOSE;
			exports.CMP_EXTENDS = CMP_EXTENDS;
		// }
		

		return Unitest;

	};

	/**
	Sets the module and particular unitest to be tested.

	- String value will perform only unitests under the same module.
	- `true` will perform all unitests regardless of the module.
	- `false` will not perform any tests.

	@def static function Unitest.only ( module, test )
	@param string|bool Name of the unitests module.
	@param string|bool|undefined Name of the unitest. `undefined` has the same effect as `true`.
	*/
	Unitest.only = function ( module, test ) {
		_setup_UNITESTS_ONLY_MODULE = module;
		_setup_UNITESTS_ONLY_TEST = test !== undefined ? test : true;
		return Unitest;
	};


	/**
	Associates a module name with the following `Unitest()` calls.

	@def static function Unitest.module ( name )
	@param string|null Name of the unitests module.
	*/
	Unitest.module = function ( name ) {
		name = name || null;
		_currentModule = name;
		return Unitest;
	};

	exports.Unitest = Unitest;
	exports.UnitestA = UnitestA;

	if ( _isNode ) {
		module.exports = Unitest;
	}

})(
	typeof global != 'undefined' ? global : this,
	typeof global != 'undefined' ? global : window
);
